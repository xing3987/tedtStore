

ssm-学子商城
	1.建立项目，配置环境
	2.创建文件夹结构
		实体：bean
		控制器：controller(在spring-mvc.xml中添加组件扫描)
		业务层：service(在spring-service.xml中添加服务层扫描)
		持久层:mapper(在spirng-dao.xml中添加接口扫描和映射文件扫描)
	3.导包
		spring-webmvc
		spring-jdbc
		mybatis
		mybatis-spring
		mysql
		commons-dbcp
		junit
		jaskson*3(异步ajax)
		jstl
	4.添加资源文件
		resources中添加属性文件	db.properties	spring-mvc.xml
		在resources中创建文件夹：mappers用于管理映射文件	
	5.配置web.xml添加dispatcherServlet, filter编码
		
***用户管理****
	1.表设计
		id   		int 				auto_increment primary key;
		username 	varchar(50)			not null unique
		password	varchar(50)			not null
		email		varchar(50)			not null
		phone		varchar(32)			not null
		image		varchar(100)						
		gender		int					0表示男,1表示女
		created_user varchar(50)
		created_time date
		modified_user varchar(50)
		modified_time date
		
	2.注册
		--创建实体类：在bean包中创建user,增加表对应字段并增加构造方法等
		--持久层：
			a.在mapper包定义接口：接口UserMap接口，并且在接口中定义insert方法
			b.在mappers文件夹中创建UserMapper.xml指定namespace
				在其中写插入语句，查询语句
			c.写测试类，测试插入，查询语句的正确性(test.java)
		--业务层
			a.创建接口IUserService,在接口中定义业务方法：register方法
				public interface IUserService{
					void register(User user);
				}
			b.创建IUserService接口的实现类：UserService，实现接口中的方法	
			c.在service.ex包中创建ClassNameAlreadyExistException异常继承RuntimeException
			d.测试UserService是否正确(test.java)
			
		--用户注册,用户名，邮箱，电话号码,用户名的验证
			a.邮箱持久层，在UserMapper接口中定义方法：验证邮箱是否存在。
				Integer selectByEmail(String email);
			b.在UserMapper.xml中定义select节点，根据邮箱查询是否存在
				返回数据类型为 java.lang.Integer
	
	3.定义通用的响应结束类ResponseResult定义到bean包中(实现序列化接口)
		包含状态码，返回信息提示，返回数据
				
	4.控制器的5个请求方法
		a.	/user/showRegister.do--显示页面
			请求参数：无
			请求方式：get
			响应方式：转发	
		b.	/user/checkUsername.do--异步请求确认用户名
			请求参数：username
			请求方式：get
			响应方式：ResponseBody
		c.	/user/checkEmail.do--异步请求确认邮箱
			请求参数：email
			请求方式：get
			响应方式：ResponseBody
		d.	/user/checkPhone.do--异步请求确认电话	
			请求参数：phone
			请求方式：get
			响应方式：ResponseBody
		e.	/user/register.do--确认登陆跳转
			请求参数：form数据
			请求方式：post
			响应方式：ResponseBody(状态码为1时通过location进行页面跳转)
		
	5.在register.jsp页面中实现用户，邮箱，手机号的异步提交(ajax)	
	
	6.用户注册，提交按钮的控制器方法(异步提交)
			register.jsp页面中该提交方法ajax的书写
			
   	**用户登陆**
   	1.登陆-持久层
   	2.登陆-业务层
   		在UserService类中实现login方法
   			a.调用持久层selectByUsername()方法，返回值User
   			b.判断user对象是否为null
   			c.如果为null,抛出异常UserNotFoundException(创建该异常)
   			d.如果不为null,从user对象中取出password,用password和页面输入的password比较
   			e.如果是true,state=1,message=登陆成功，返回user
   			f.如果是false,抛出异常PasswordNotMatchException(创建密码不匹配异常)
	3.登陆-控制层
		在UsreController类中定义方法
			a.跳转到登陆页面
			b.点击登陆时跳转到主页并绑定session
			c.验证用户名（ajax）
		在login.jsp中写登陆和验证用户名的ajax代码	
			写点击记住密码保存cookie的函数
		
	4.页面调整
		注册成功之后，跳转到登陆
		在注册的页面，点击直接登陆，跳转到登陆页面

**首页管理**
	1.登陆成功跳转到首页
	2.在index.jsp页面，显示用户名，在右上角	
		${user.username}	
	3.如果没有显示用户名，显示登陆，如果显示用户名，显示退出	
		引入标签库
		<c:if test="${user!=null}">退出</c:if>	
	4.点击登陆，跳转到登陆页面	
	5.点击退出，退出到首页，清除session
		在UserController,定义方法，完成退出的功能
		public String exit(HttpSession session){
			session.invalidate();
			return "../main/showIndex.do";
		}
	6.截取header.jsp，在index.jsp页面动态包含header.jsp
	7.点击用户名时，显示用户信息管理页面：	personal_password
		在UserController中定义方法，方法名showPersonal.do
		
***安全管理***		
		1.持久层
			a.在UserMapping接口中定义方法
					修改用户信息：void update(User user)
				在UserMapper.xml文件中，定义update节点，并写sql语句
				<update id="update" parameterType="....User">
					update t_user set 
						<if test="password!=null">
							password=#{password},
						</if>
						<if test="username!=null">
							username=#{username},
						</if>
						<if test="gender!=null">
							gender=#{gender},
						</if>
						<if test="email!=null">
							email=#{email},
						</if>
						<if test="phone!=null">
							phone=#{phone},
						</if>
						modified_user=#{modifiedUser},
						modified_time=#{modifiedTime} 
					 where id=#{id}
				</update>
				测试：修改密码成功
			b.创建方法User selectById()	
				在UserMapper.xml文件中，定义selectById方法
		
		2.业务层
			在IUserService接口中定义方法
				void changePassword(Integer id,String oldPwd,String newPwd)
			在UserService类中实现方法
				void changePassword(Integer id,String oldPwd,String newPwd){
					1.调用selectById得到用户
					2.判断user!=null，获取密码
					3.获取密码和oldPwd进行判断
					4.如果结果返回true
						User u=new User
						u.setId(..);u.setPassword()
					5.调用持久层update(u)
					6.返回false抛异常
				}
					
		3.控制器层
			在MainController中定于方法
				public ResponseResult<Void> password
			书写跳转到personInfo.jsp的代码
		4.  在personal_password.jsp中用jQuery写验证密码，点击提交的ajax语句
			调整各个按钮的连接地址及左边下拉列表的显示
		5.  在personInfo.jsp中调整页面以及各个连接
		
		6. 个人信息-修改
			a.持久层
			b.业务层			
				在IUserService定义方法
					void update(Integer id,String username,Integer gender,String phone,String email);
				在UserService中实现方法
				void update(Integer id,String username,Integer gender,String phone,String email){
					User user=new User();
					判断username是否存在
					User u1=userMapper.selectByUsername(username);
					如果u1==null||username.equals(u1.getUsername)//用户名为空或者是当前用户
						user.setUsername(username);
					否则
							抛出用户名已经存在的异常					
				}
			c.控制层
				UserController中添加public ResponseResult<Void> personInfo(HttpSession session, 
							String username,Integer gender,String phone,String email)方法
							
							方法中注意重新session绑定user
			
			d.处理页面personInfo.jsp保存更改的功能
		
		
***登陆拦截器**
		Filter:web组件，web容器	过滤web组件---jsp,servlet等
		Interceptor:spring组件  拦截controller---从前端到controller，从后端到前端时执行
		1.	拦截：showPersonInfo.do
					personInfo.do
					showPersonal.do
					personal.do
		2.	在store中创建拦截器的包intercept
				创建拦截器的类LoginInterceptor
				public class LoginInterceptor implements HandlerInterceptor{}	
					在perHandler方法中写：
						1.判断session user是否为null
						2.如果为null,重定向到登陆界面
						3.如果不为null,继续执行controller方法	
		3. 在spring-mvc.xml中配置拦截器
		
**地址管理******
		创建表t_address,省市区存对应编号
		create table t_address(
			id int auto_increment primary key,
			uid int not null,
			recv_name varchar(50) not null,
			recv_province varchar(6),
			recv_city varchar(6) not null,
			recv_area varchar(6) not null,
			recv_distric varchar(100) not null,
			recv_address varchar(100) not null,
			recv_phone varchar(32) not null,
			recv_tel varchar(32),
			recv_zip varchar(6),
			recv_tag varchar(10),
			created_user varchar(50),
			created_time date,
			modified_user varchar(50),
			modified_time date
		)engine=InnoDB default charset=utf8
		
		1.添加地址，新建地址管理控制器：AddressController
			a.显示页面并修改成.jsp格式，替换头部和左边栏
			b.制作地址三级联动菜单
				1.导入全国地址表t_dict.sql
				
				2-1.持久层
					1.创建Province实体类
						参照表的字段驼峰式创建bean
					2.创建DectMapper接口，定义方法selectProvince;
							List<Province> selectProvince();
					3.新建DictMapper.xml用于保存省信息查询等功能
						写查询语句
					4.测试持久层
				2-2.业务层	
					创建接口IDictService,并定义方法
						List<Province> getProvince();
					创建接口的实现类:DictService,实现方法
						public List<Province> getProvince(){}
				2-3.控制器层("/dict")
					创建控制器类：DictController
						创建方法：
							public ResponseResult<List<Province>> showProvince(){
								List<Province> provinces=dictService.getProvince();
							}
				2-4.表示层写ajax异步提交代码
						//显示城市信息
						function getCity(provinceCode){
							$.ajax({
								"url":"${pageContext.request.contextPath}/dict/showCity.do",
								"data":"provinceCode="+provinceCode,
								"type":"GET",
								"dataType":"json",
								"success":function(obj){
									var cityNames=obj.data;
									$("#receiverCity").html("<option>&nbsp;&nbsp;- - - 选择市 - - -&nbsp;&nbsp;</option>");
									for(var i=0;i<cityNames.length;i++){
										$("#receiverCity").append("<option value='"+cityNames[i].cityCode+"'>"+cityNames[i].cityName+"</option>");
									}
								}
							});
						}
						//显示省列表信息
						$(function(){		
							$.ajax({
								"url":"${pageContext.request.contextPath}/dict/showProvince.do",
								"type":"GET",
								"dataType":"json",
								"success":function(obj){
									var provinceNames=obj.data;
									for(var i=0;i<provinceNames.length;i++){
										$("#receiverState").append("<option value='"+provinceNames[i].provinceCode+"'>"+provinceNames[i].provinceName+"</option>");
									}
								}
							});
						});
				3.写城市和区域的代码（参照省份）		
					1.创建City实体类
					2.在DectMapper接口中定义方法selectCity
					3.在配置DectMapper.xml中定义查询语句
					4.测试持久层
					5.在页面jsp文件上写ajax异步提交代码
				
				4.省市区函数调整
					getProvince(provinceCode,cityCode,areaCode)
					getCity(provinceCode,cityCode,areaCode)
					getArea(cityCode,areaCode)
					
					如：getProvince(-1,-1,-1)
				5.创建方法，通过code查询省份，城市，区域
					selectProvinceNameByCode
					selectCityNameByCode
					selectAreaNameByCode
					在DectMapper中配置查询语句
					
			c.添加地址点击提交按钮
				1.	在bean包创建表对应的bena--Address.java
				2.	在mapper包中创建AddressMapper接口，在接口中定义方法：
						void insert(Address address);
				3.	新建AddressMapper.xml文件
				4.	定义insert节点，完成插入地址信息的功能 
				
			d.添加收货地址
				1.持久层
					增加通过uid查询Address方法
				2.业务层
					1.在service包中，新建IAddressService,定义方法
						void addAddress(Address address);
							
					2.新建AddressService实现类，实现以上方法
						public void addAddress(Address address){}
				
					3.从address中获取省市区的code,调用dictMapper中提供的方法，
					     获取到code对应的name,再把3个name 用+连接成新串，把此字符串
					    设置到address中
					    address.setDistrict();
					4.给isDefault设置值
						调用selectByUid方法，该方法返回list
						如果list.size()>0,address的isDefault
				
				3.控制层
					在AddressController定义方法
						public ResponseResult<Void> address(HttpSession session,
						@RequestParam("receiverName") String recvName,
						@RequestParan("receiverState) String recvProvince,
						@RequestParam("receiverCity") String recvCity,
						@RequestParam("receiverDistrict") String recvArea,
						@RequestParam("receiverAddress") String recvAddress,
						@RequestParam("receiverMobile") String recvPhone,
						@RequestParam("receiverPhone") String recvTel,
						@RequestParam("receiverZip") String recvZip,
						@RequestParam("addressName") String recvTag){
							1.创建rr对象
							2.调用业务层方法
							3.设置rr的状态码和信息
							4.return rr;
						}
			
		2.显示地址
			1.在IAddressService接口中，定义方法
				List<Address> getAddressByUid(Integer uid){}
			2.在AddressService类中实现方法
				public List<Address> getAddressByUid(Integer uid){}
			3.控制层public ResponseResult<List<Address>> getAddressByUid(HttpSession session){}	
			4.jsp页面显示收货人信息，通过ajax把从控制层得到的json串转换成页面
		
		3.显示地址设置默认
			1.在AddressMapper接口定义2个方法：
				Integer setCancel(Integer uid)//把登陆用户所有的default_address设置为0
				Integer setDefault(Integer id)//把选中的用户的default_address设置为1
			2.在AddressMapper.xml文件中定义这两个方法
				update t_address set default_address=0 where uid=#{uid}
				update t_address set default_address=1 where id=#{id}	
			     在IAddressService接口中定义方法
			     	void setDefault(Integer uid,Integer id);
			   在AddressService类中实现方法
			   	public void setDefault(Integer uid,Integer id){
			   		1.调用持久层方法setCancel(),如果方法返回0，抛出异常
			   		2.调用持久层方法setDefault(),如果方法返回0,抛出异常
			   	}
			3.在控制层定义方法	
				public ResponseResult<Void> getDefault(HttpSession session,Integer id){}
			4.定义页面的ajax函数	
		4.修改收货地址
			1.回显收货地址
				a.持久层				
					在AddressMapper接口中定义方法：
						Address selectAddressById(Integer id)
					在AddressMapper.xml中，定义select节点
				b.业务层
					在IAddressService接口中定义方法
						Address getAddressById(Integer id);
					在AddressService中实现该方法
				c.控制器层
					public ResponseResult<Address> getAddressById(Integer id) {}
				d.页面按钮添加事件，用ajax访问控制器
					修改三级联动的代码，增加参数传递
					最后在表单中添加一个隐藏的input里面放入id值
			2.点击修改
				a.持久层
					在AddressMapper接口中定义方法
						void updateById(Address address);
					在AddressMapper.xml中，定义update节点
				b.测试sql语句的正确性
				c.服务层
					在IAddressService实现方法
						public void updateAddressById(Address address)
					在AddressService中实现该方法
						注意recvDistrict地址的拼接
				d.控制器
					/address/updateAddress.do
					请求参数：form数据
					请求方式：POST
					响应方式:ResponseBody成功信息
						public ResponseResult<Void> updateAddress(
						Integer id,
						@RequestParam("receiverName") String recvName,
						@RequestParan("receiverState) String recvProvince,
						@RequestParam("receiverCity") String recvCity,
						@RequestParam("receiverDistrict") String recvArea,
						@RequestParam("receiverAddress") String recvAddress,
						@RequestParam("receiverMobile") String recvPhone,
						@RequestParam("receiverPhone") String recvTel,
						@RequestParam("receiverZip") String recvZip,
						@RequestParam("addressName") String recvTag){
							1.创建rr对象
							2.调用业务层方法
							3.设置rr的状态码和信息
							4.return rr;
						}	
				e.编写页面jsp的ajax代码				
					修改成功后，按钮要改回‘保存联系人信息’
		5.点击删除按钮
			a.在AddressMapper接口定义方法
				void deleteById(Integer id);
			b.在AddressMapper.xml中添加删除语句
			c.编写控制层，服务层;
						
*********商品管理*********
	1.showIndex.do主界面显示商品分类信息
		1.持久层：
			a.首先新建GoodsCategory实体类；定义接口GoodsCategoryMapper,在接口中定义方法
				//分页查询，子类商品，因为参数有多个可以使用两种方法
					1.封装成一个类，当一个参数传递
					2.使用@Param注解进行封装传递
				List<GoodsCategory> selectByParentId(@Param("parentId") Integer parendId,
						@Param("offset") Integer offset,@Param("count") Integer count);					
			b.新建GoodsCategoryMapper.xml;配置映射名称，写查询语句。			
				<select id="selectCategoryByParentId" resultType=" ">
					select xx from t_goods_category 
					where parent_id=#{parentId}
					and status=1	//上架状态
					<if test="offset!=null">//如果有分页查询参数传递时
						limit #{offset},#{count}
					</if>
				</select>	
			c.测试持久层		
		2.业务层
			a.新建IGoodsCategoryService接口，在接口中定义方法
				List<GoodsCategory> getCategoryByParentId(Integer parentId,
					Integer offset,Integer count);
			b.新建接口实现类GoodsCategoryServic,实现接口的方法
		3.控制层
			使用MainController类中的showIndex(ModelMap map)方法
			a.调用getCategoryByParentId(161,0,3),返回二级分类集合computerList
			b.遍历二级分类集合，得到二级分类的对象，从对象中得到id,
				调用getCategoryByParentId(id,null,null),返回三级分类集合category161List
			c.方法添加ModelMap(spring-mvc用来传递request)参数
				把两个集合分别设置到map中
		4.页面
			--index.jsp在电脑.办公/1F中把得到的数据用el表达式,forEach标签放入两个List中的数据

	2.热门商品的显示
		1.持久层
			a.新建Goods实体类对应数据库表：t_goods
			b.新建GoodsMapper接口，在接口中定义方法(分页查询显示3个热点商品)
				List<Goods> select(@Param("categoryId") Integer categoryId,
					@Param("offset") Integer offset,@Param("count") Integer count)
			c.新建GoodsMapper.xml，添加查询方法
				select * from t_goods where category_id=#{categoryId}
									  add num>0 and status=1
									  order by priority desc 
									  limit #{offset},#{count}
		2.业务层IGoodsService接口，GoodsService实现类
			写对应的方法
		3.控制层
			参照商品分类信息控制层(写在showIndex(Model map)中)	
		4.页面
			注意forEach标签的使用和多重嵌套varstatu--index的使用

	3.商品展示页面search.jsp
		1.新建GoodsController类，定义showSearch方法，完成显示页面
					
					
					
					
					
					
					
					
					
						
					
					
					
					
					
					
					
					
					
					
					
					
					
					
							
				
				
					